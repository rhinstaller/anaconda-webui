#!/usr/bin/python3
#
# Copyright (C) 2021 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

from anacondalib import VirtInstallMachineCase
from installer import Installer
from testlib import nondestructive, test_main, wait  # pylint: disable=import-error
from utils import get_pretty_name


@nondestructive
class TestBasic(VirtInstallMachineCase):

    def testNavigation(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)

        i.open()

        self.assertIn(
            b.attr("#app .pf-v5-c-page", "data-debug").lower(),
            ["false", "true"]
        )

        i.check_prerelease_info()
        # Do not start the installation in non-destructive tests as this performs non revertible changes
        # with the pages basically empty of common elements (as those are provided by the top-level installer widget)
        # we at least iterate over them to check this works as expected
        i.reach(i.steps.REVIEW)

        # Ensure that the 'actual' UI process is running/
        self.assertIn("/usr/libexec/anaconda/webui-desktop", m.execute("ps aux"))

    def testSidebarNavigation(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)

        i.open()

        i.check_prerelease_info()

        # Test that clicking on current step does not break navigation
        i.click_step_on_sidebar()

        i.reach(i.steps.REVIEW)

        # Test going back
        steps = [
            i.steps.ACCOUNTS,
            i.steps.STORAGE_CONFIGURATION,
            i.steps.INSTALLATION_METHOD,
            i.steps.LANGUAGE,
        ]

        for step in steps:
            if step not in i.steps.hidden_steps:
                i.click_step_on_sidebar(step)

        i.reach(i.steps.REVIEW)

        # Check disabling of later steps when going back
        i.reach_on_sidebar(i.steps.LANGUAGE)
        for step in [
            i.steps.ACCOUNTS,
            i.steps.STORAGE_CONFIGURATION,
            i.steps.INSTALLATION_METHOD,
            i.steps.REVIEW,
        ]:
            i.check_sidebar_step_disabled(step)

    def testAboutModal(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)

        i.open()

        # Obtain pretty name and versions from the CLI
        pretty_name = get_pretty_name(m)
        version = m.execute("anaconda --version | cut -d ' ' -f 2 | tail -1")

        # Click on the kebab
        b.click("#toggle-kebab")

        # Click on the "About" item from the dropdown
        b.click("#about-modal-dropdown-item-about")

        # Expect PRETTY_NAME to be shown in modal title
        b.wait_in_text("#about-modal-title", pretty_name)

        # Expect "Powered by Anaconda" to be shown in modal subtitle
        b.wait_in_text("#about-modal-subtitle", "Powered by Anaconda")

        # Expect About modal body to be shown
        b.wait_in_text("#about-modal-versions dt", "Anaconda")
        b.wait_in_text("#about-modal-versions dd", version.strip())

        # Expect button link for Anaconda project page to be shown
        b.wait_in_text("#anaconda-page-button", "Anaconda project page")

        # Pixel test the language step
        b.assert_pixels(
            ".pf-v5-c-about-modal-box",
            "about-modal",
            ignore=["#about-modal-versions dd"],
        )

        # Close about modal
        b.click(".pf-v5-c-button[aria-label='Close Dialog']")
        b.wait_not_present("#about-modal")

    def _testLogReview(self, b, m, idPrefix):
        # Test review of logs
        self.addCleanup(m.execute, "rm -f /tmp/webui.log")
        logfile = "/tmp/webui.log"

        self.assertFalse(self.file_exists(logfile))

        # FIXME: Remove PF5 specific selector: https://github.com/patternfly/patternfly-react/issues/9512
        # Click report issue: save reviewed log and open BZ URL
        b.click(f"#{idPrefix}-bz-report-modal.pf-v5-c-modal-box .pf-v5-c-button.pf-m-primary")

        with b.wait_timeout(20):
            b.wait(lambda: self.file_exists(logfile))

        # Reviewed log contains more than 100 lines
        wait(lambda: int(m.execute(f"wc -l {logfile} | cut -d' ' -f1").strip()) > 1)

        # Test editing of the log
        user_text = "STRING_ADDED_BY_USER_TO_LOG"
        b.set_input_text(f"#{idPrefix}-bz-report-modal-review-log", user_text)
        b.click(f"#{idPrefix}-bz-report-modal.pf-v5-c-modal-box .pf-v5-c-button.pf-m-primary")
        wait(lambda: (m.execute(f"cat {logfile}")) == user_text)

    def testReportIssue(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)

        i.open()

        # FIXME: Remove PF5 specific selector: https://github.com/patternfly/patternfly-react/issues/9512
        b.wait_not_present("#user-issue-bz-report-modal.pf-v5-c-modal-box")

        b.click("#toggle-kebab")

        # Clean up the journal before we open Report dialog
        # (Report dialog presents all journal in a textarea)
        # to avoid crashing the test browser
        m.execute("journalctl --rotate; journalctl --vacuum-time=1s")

        b.click("#about-modal-dropdown-item-report")

        b.wait_visible("#user-issue-bz-report-modal.pf-v5-c-modal-box")

        self._testLogReview(b, m, "user-issue")

        b.click("#user-issue-dialog-cancel-btn")
        b.wait_not_present("#user-issue-bz-report-modal.pf-v5-c-modal-box")

    def testJsErrorHandling(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)

        i.open()

        # Clean up the journal before we open Report dialog
        # (Report dialog presents all journal in a textarea)
        # to avoid crashing the test browser
        m.execute("journalctl --rotate; journalctl --vacuum-time=1s")

        b.wait_not_present("#critical-error-bz-report-modal.pf-v5-c-modal-box")

        b.eval_js("window.setTimeout(function() { myNonExistingFunction()}, 0);")
        b.wait_in_text("#critical-error-bz-report-modal-details", "myNonExistingFunction is not defined")

        b.wait_visible("a:contains('Report issue'):not([disabled])")
        b.assert_pixels(
            "#critical-error-bz-report-modal.pf-v5-c-modal-box",
            "js-error-modal",
            ignore=["#critical-error-bz-report-modal-review-log"]
        )


if __name__ == '__main__':
    test_main()
