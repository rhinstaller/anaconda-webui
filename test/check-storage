#!/usr/bin/python3
#
# Copyright (C) 2022 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

import anacondalib

from installer import Installer
from storage import Storage
from review import Review
from testlib import nondestructive, test_main  # pylint: disable=import-error
from storagelib import StorageHelpers  # pylint: disable=import-error


@nondestructive
class TestStorage(anacondalib.VirtInstallMachineCase):

    def testLocalStandardDisks(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        i.open()
        i.next()

        b.wait_in_text('#installation-wizard', 'Local standard disks')

        # Check disks table details
        s.check_disk_visible("vda")
        s.check_disk_selected("vda", True)
        s.check_disk_capacity("vda", "16.1 GB", "16.1 GB")

        # Pixel test the storage step
        b.assert_pixels(
            "#app",
            "storage-step-basic",
            ignore=["#betanag-icon", "#installation-destination-table-label", "#installation-destination-hint"],
            wait_animations=False,
        )

        # Check bulk selection of disks
        s.select_all_disks_and_check(["vda"])
        s.select_none_disks_and_check(["vda"])

        s.click_checkbox_and_check_all_disks(["vda"], selected=True)
        s.click_checkbox_and_check_all_disks(["vda"], selected=False)

        # Check that the disk selection persists when moving next and back
        s.select_disk("vda", True)
        i.next()
        i.back()
        s.check_disk_selected("vda", True)

        # Try unselecting the single disk and expect and error
        s.select_disk("vda", False)
        s.wait_no_disks()
        # Check the next button is disabled if no disks are selected
        i.check_next_disabled()

    # Test moving back and forth between screens.
    # Disk initialization mode is applied to the backend in the test.
    # Partitioning is not applied to the backend in the test.
    def testAutopartitioning(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        i.open()
        # Language selection

        i.reach(i.steps.STORAGE_CONFIGURATION)

        # Check the default mode
        s.check_partitioning_selected("erase-all")

        b.assert_pixels(
            "#app",
            "storage-step-autopart",
            ignore=["#betanag-icon"],
            wait_animations=False,
        )

        s.set_partitioning("use-free-space")

        i.next()
        # Disk Encryption

        b.assert_pixels(
            "#app",
            "storage-step-encrypt",
            ignore=["#betanag-icon"],
            wait_animations=False,
        )

        s.check_encryption_selected(False)
        encrypt = True
        s.set_encryption_selected(encrypt)

        i.back()
        # Storage Configuration
        # The choice is preserved (stored in the backend).
        s.check_partitioning_selected("use-free-space")

        i.next()
        # Disk Encryption
        # The value is preserved
        s.check_encryption_selected(encrypt)

        # Disk Encryption / password screen
        b.assert_pixels(
            "#app",
            "storage-step-password",
            ignore=["#betanag-icon"],
            wait_animations=False,
        )

        # No password set
        s.check_pw_rule("8-chars", "indeterminate")
        s.check_pw_rule("match", "indeterminate")
        i.check_next_disabled()

        # Set pw which is too short
        s.set_password("abcd")
        s.check_pw_strength(None)
        i.check_next_disabled()
        s.check_pw_rule("8-chars", "error")
        s.check_pw_rule("match", "error")

        # Make the pw 8 chars long
        s.set_password("efgh", append=True, value_check=False)
        i.check_next_disabled()
        s.check_password("abcdefgh")
        s.check_pw_rule("8-chars", "success")
        s.check_pw_rule("match", "error")
        s.check_pw_strength("weak")

        # Set the password confirm
        s.set_password_confirm("abcdefg")
        s.check_pw_rule("match", "error")
        s.set_password_confirm("abcdefgh")
        s.check_pw_rule("match", "success")
        s.check_pw_rule("8-chars", "success")
        s.check_pw_strength("weak")
        s.check_password("abcdefgh")
        s.check_password_confirm("abcdefgh")
        i.check_next_disabled(disabled=False)

        # Check setting strong password
        s.set_password("Rwce82ybF7dXtCzFumanchu!!!!!!!!")
        s.check_pw_strength("strong")

    # Test moving back after partitioning is applied,
    # the partitioning should be reset.
    def testAutopartitioningReset(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        i.open()
        # Language selection

        i.reach(i.steps.STORAGE_CONFIGURATION)

        # Check the default mode
        s.check_partitioning_selected("erase-all")

        s.set_partitioning("use-free-space")

        i.next()
        # Disk Encryption

        encrypt = True
        s.set_encryption_selected(encrypt)
        s.check_encryption_selected(encrypt)

        # Encryption password is on the same page
        i.next(subpage=encrypt)
        # Disk Encryption / password screen

        # Set valid password
        pw = "abcdefgh"
        s.set_password_confirm(pw)
        s.check_password_confirm(pw)
        s.set_password(pw)
        s.check_password(pw)

        i.check_next_disabled(disabled=False)

        i.next()
        # Review screen

        i.back()
        # Disk Encryption
        s.check_password_confirm(pw)
        s.check_password(pw)
        s.check_encryption_selected(encrypt)

        i.back()
        # Storage Configuration
        # The choice is preserved (stored in the backend).
        # The choice is available only if the partitioning was reset
        # (there is enough free space)
        s.check_partitioning_selected("use-free-space")

    def testPartitioningObject(self):
        # Test which partitioning object ends up being the AppliedPartitioning
        # when we go back and forward the storage steps

        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        self.addCleanup(s.dbus_reset_partitioning)

        # Read partitioning data before we do anything
        created_partitioning = s.dbus_get_created_partitioning()

        # Go to Review step
        i.open()
        i.next()
        i.next()
        i.next()
        i.next()

        # Read partitioning data after we went to Review step
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        new_created_partitioning = s.dbus_get_created_partitioning()

        # A new AUTOMATIC partitioning object should be created each time the user enters the review page
        self.assertEqual(len(created_partitioning) + 1, len(new_created_partitioning))
        # The applied partitioning object should be the last one created
        self.assertEqual(new_applied_partitioning, new_created_partitioning[-1])

        created_partitioning = new_created_partitioning

        # Create a few partitioning objects and ensure that these will not mess up with the user's
        # configuration
        for _ in range(10):
            s.dbus_create_partitioning("AUTOMATIC")

        # Go back to the previous page and re-enter the review screen.
        # This should create again a new partitioning object and apply it
        # no matter how many partitioning objects were created before
        i.back()
        i.next()
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        new_created_partitioning = s.dbus_get_created_partitioning()

        self.assertEqual(len(created_partitioning) + 11, len(new_created_partitioning))
        self.assertEqual(new_applied_partitioning, new_created_partitioning[-1])


# TODO add next back test keeping the choice
@nondestructive
class TestStorageExtraDisks(anacondalib.VirtInstallMachineCase, StorageHelpers):

    def testLocalDisksSyncNew(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        # This attaches a disk to the running VM
        # However, since the storage module initialization is long completed
        # the newly added disk, will not be visible in the UI,
        # until the test clicks on the re-scan button
        dev = self.add_ram_disk(2)
        dev = dev.split("/")[-1]

        i.open()
        i.next()

        s.wait_no_disks_detected_not_present()

        s.check_disk_visible("vda")
        s.check_disk_visible(dev, False)

        s.rescan_disks()
        s.check_disk_visible("vda")
        s.check_disk_visible(dev)

        s.wait_no_disks_detected_not_present()

        s.check_disk_selected("vda", False)
        s.check_disk_selected(dev, False)

        s.rescan_disks()
        s.wait_no_disks_detected()

        # Check that disk selection is kept on Next and Back
        disks = [dev]
        for disk in disks:
            s.select_disk(disk)
        i.next()
        i.back()
        for disk in disks:
            s.check_disk_selected(disk)


    def testStoragePartitions(self):
        b = self.browser
        m = self.machine

        dev = self.add_ram_disk(100)

        m.execute(f'parted -s {dev} mktable gpt')
        m.execute(f'parted -s {dev} mkpart primary ext4 0% 20%')
        m.execute(f"echo einszweidrei | cryptsetup luksFormat {dev}1")

        m.execute(f'parted -s {dev} mkpart primary ext4 20% 60%')
        m.execute(f'mkfs.ext4 {dev}2')

        i = Installer(b, m)
        s = Storage(b, m)

        i.open()
        i.next()

        s.check_disk_selected("vda", True)

        s.rescan_disks()

        dev = dev.split("/")[-1]
        s.check_disk_visible("vda")
        s.check_disk_expandable("vda", False)
        s.check_disk_visible(dev, False)
        s.check_disk_expandable(dev, True)

        s.set_expand_disk_row(dev, True)
        s.check_disk_partition(dev, f"/dev/{dev}1", "Encrypted (LUKS)", "21.0 MB")
        s.check_disk_partition(dev, f"/dev/{dev}2", "ext4", "41.9 MB")

        s.check_disk_selected("vda", False)
        s.check_disk_selected(dev, False)

        b.assert_pixels(
            "#app",
            "storage-step-basic-partitions",
            wait_animations=False,
        )

class TestStorageMountPoints(anacondalib.VirtInstallMachineCase):

    def select_mountpoint(self, i ,s, disks, expected_partitions):
        i.open()
        i.next()

        s.check_disk_visible("vda")

        s.rescan_disks()
        for disk in disks:
            dev = disk.split('/')[-1]
            s.select_disk(dev)
            s.set_expand_disk_row(dev, True)

        for disk, partitions in expected_partitions.items():
            dev = disk.split('/')[-1]
            for partition in partitions:
                s.check_disk_partition(dev, partition)

        i.next()
        s.set_partitioning("custom-mount-point")

        i.next(next_page=i.steps.CUSTOM_MOUNT_POINT)

    def select_from_dropdown(self, row, name, mountpoint, create=False):
        b = self.browser
        if create:
            b.set_input_text(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Mount point'] .pf-c-form-control.pf-c-select__toggle-typeahead", mountpoint)
            b.click(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Mount point'] button.pf-c-select__menu-item")
        else:
            b.click(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Mount point'] .pf-c-select__toggle button")
            b.click(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Mount point'] .pf-c-select__menu-item.select-option-{name}")
        b.wait_val(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Mount point'] .pf-c-select__toggle-typeahead", mountpoint)

    def check_format_type(self, row, format_type):
        self.browser.wait_in_text(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Format type']", format_type)

    def check_partition(self, row, partition):
        self.browser.wait_in_text(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Partition']", partition)

    def unlock_device(self, passphrase, xfail=None):
        self.browser.wait_visible("#unlock-device-dialog")
        self.browser.set_input_text("#unlock-device-dialog-luks-password", passphrase)
        self.browser.click("#unlock-device-dialog-submit-btn")
        if xfail:
            self.browser.wait_in_text("#unlock-device-dialog .pf-c-alert", xfail)
            self.browser.click("#unlock-device-dialog-cancel-btn")
        self.browser.wait_not_present("#unlock-device-dialog")

    def select_reformat(self, row):
        self.browser.set_checked(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Reformat'] input", True)

    def check_reformat(self, row, checked):
        checked_selector = "input:checked" if checked else "input:not(:checked)"
        self.browser.wait_visible(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Reformat'] {checked_selector}")

    def check_select_disabled(self, row):
        self.browser.wait_visible(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Mount point'] .pf-c-select__toggle.pf-m-disabled")

    def check_reformat_disabled(self, row):
        self.browser.wait_visible(f"#custom-mountpoint-table tbody tr:nth-child({row}) td[data-label='Reformat'] .pf-c-check__input:disabled")

    def assert_inline_error(self, text):
        self.browser.wait_in_text(".pf-c-alert.pf-m-inline.pf-m-danger", text)

    def udevadm_settle(self):
        # Workaround to not have any empty mountpoint labels
        self.machine.execute("""
        udevadm trigger
        udevadm settle --timeout=120
        """)

    def testBasic(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        disk = "/dev/vda"
        m.execute(f"""
        sgdisk --zap-all {disk}
        sgdisk --new=0:0:+1MiB -t 0:ef02 {disk}
        sgdisk --new=0:0:+1GiB {disk}
        sgdisk --new=0:0:+10GiB {disk}
        sgdisk --new=0:0:0 {disk}
        mkfs.ext4 {disk}2
        mkfs.xfs {disk}3
        mkfs.btrfs {disk}4
        """)

        self.udevadm_settle()
        partitions = {}
        partitions[disk] = [f"{disk}2", f"{disk}3", f"{disk}4"]
        self.select_mountpoint(i, s, [disk], partitions)

        # verify gathered requests
        self.check_format_type(1, "biosboot")
        self.check_select_disabled(1)
        self.check_reformat_disabled(1)

        self.check_format_type(2, "ext4")
        self.select_from_dropdown(2, "boot", "/boot")
        self.check_reformat(2, False)

        self.check_format_type(3, "xfs")
        self.select_from_dropdown(3, "root", "/")
        self.check_reformat(3, True)

        self.check_format_type(4, "btrfs")
        self.select_from_dropdown(4, "home", "/home")
        self.check_reformat(4, False)
        self.check_reformat_disabled(4)

        # Toggle reformat option
        self.select_reformat(2)
        self.check_reformat(2, True)

        b.assert_pixels(
            "#app",
            "custom-mountpoint-table",
            wait_animations=False,
        )

        i.next()

        # verify review screen
        disk = "vda"
        r.check_disk_label(disk, disk)
        r.expand_disk_table(disk)

        row = 1
        r.check_disk_row(disk, row, "Partition", f"/dev/vda{row}")
        r.check_disk_row(disk, row, "Format type", "biosboot")
        row = 2
        r.check_disk_row(disk, row, "Partition", f"/dev/vda{row}")
        r.check_disk_row(disk, row, "Format type", "ext4")
        r.check_disk_row(disk, row, "Mount point", "/boot")
        r.check_disk_row_reformatted(disk, row, "Reformat")
        row = 3
        r.check_disk_row(disk, row, "Partition", f"/dev/vda{row}")
        r.check_disk_row(disk, row, "Format type", "xfs")
        r.check_disk_row(disk, row, "Mount point", "/")
        r.check_disk_row_reformatted(disk, row, "Reformat")
        row = 4
        r.check_disk_row(disk, row, "Partition", f"/dev/vda{row}")
        r.check_disk_row(disk, row, "Format type", "btrfs")
        r.check_disk_row(disk, row, "Mount point", "/")

    def testNoRootMountPoint(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        # BIOS boot /boot on ext4 / on xfs /home on btrfs
        disk = "/dev/vda"
        m.execute(f"""
        sgdisk --zap-all {disk}
        sgdisk --new=0:0:+1MiB -t 0:ef02 {disk}
        sgdisk --new=0:0:+1GiB {disk}
        sgdisk --new=0:0:+10GiB {disk}
        sgdisk --new=0:0:0 {disk}
        mkfs.ext4 {disk}2
        mkfs.xfs {disk}3
        mkfs.ext4 {disk}4
        """)

        self.udevadm_settle()

        partitions = {}
        partitions[disk] = [f"{disk}2", f"{disk}3", f"{disk}4"]
        self.select_mountpoint(i, s, [disk], partitions)

        # verify gathered requests
        self.check_format_type(1, "biosboot")
        self.check_select_disabled(1)
        self.check_reformat_disabled(1)

        self.check_format_type(2, "ext4")
        self.select_from_dropdown(2, "boot", "/boot")
        self.check_reformat(2, False)

        self.check_format_type(3, "xfs")
        self.select_from_dropdown(3, "/foo", "/foo", create=True)
        self.check_reformat(3, False)

        self.check_format_type(4, "ext4")
        self.select_from_dropdown(4, "home", "/home")
        self.check_reformat(4, False)

        i.next(should_fail=True)
        self.assert_inline_error("You have not defined a root partition")

    def testMultipleDisks(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        m.add_disk(10)

        # BIOS boot partition, /boot partition, /
        disk1 = "/dev/vda"
        m.execute(f"""
        sgdisk --zap-all {disk1}
        sgdisk --new=0:0:+1MiB -t 0:ef02 {disk1}
        sgdisk --new=0:0:+1GiB {disk1}
        sgdisk --new=0:0:0 {disk1}
        mkfs.xfs {disk1}2
        mkfs.xfs {disk1}3
        """)

        # /dev/vdb1 /home partition
        disk2 = "/dev/vdb"
        m.execute(f"""
        sgdisk --zap-all {disk2}
        sgdisk --new=0:0 {disk2}
        mkfs.xfs {disk2}1
        """)

        self.udevadm_settle()

        partitions = {}

        # Select first only vdb disk and verify that the partitioning request is correct
        partitions[disk2] = [f"{disk2}1"]
        self.select_mountpoint(i, s, [disk2], partitions)

        self.check_partition(1, "/dev/vdb1")

        # Go back and change the disk selection. The partitioning should be re-created
        b.click("button:contains(Back)")
        b.click("button:contains(Back)")
        b.click("button:contains(Back)")

        partitions[disk1] = [f"{disk1}2", f"{disk1}3"]
        self.select_mountpoint(i, s, [disk1, disk2], partitions)

        self.check_partition(1, "/dev/vda1")

        self.check_partition(2, "/dev/vda2")
        self.check_format_type(2, "xfs")
        self.select_from_dropdown(2, "boot", "/boot")
        self.check_reformat(2, False)

        self.check_partition(3, "/dev/vda3")
        self.check_format_type(3, "xfs")
        self.select_from_dropdown(3, "root", "/")
        self.check_reformat(3, True)

        self.check_partition(4, "/dev/vdb1")
        self.check_format_type(4, "xfs")
        self.select_from_dropdown(4, "home", "/home")
        self.check_reformat(4, False)

        i.next()

        # verify review screen
        disk = "vda"
        r.check_disk_label(disk, disk)
        r.expand_disk_table(disk)

        row = 1
        r.check_disk_row(disk, row, "Partition", f"/dev/vda{row}")
        r.check_disk_row(disk, row, "Format type", "biosboot")
        row = 2
        r.check_disk_row(disk, row, "Partition", f"/dev/vda{row}")
        r.check_disk_row(disk, row, "Format type", "xfs")
        r.check_disk_row(disk, row, "Mount point", "/boot")
        row = 3
        r.check_disk_row(disk, row, "Partition", f"/dev/vda{row}")
        r.check_disk_row(disk, row, "Format type", "xfs")
        r.check_disk_row(disk, row, "Mount point", "/")
        r.check_disk_row_reformatted(disk, row, "Reformat")

        disk = "vdb"
        r.check_disk_label(disk, disk)
        r.expand_disk_table(disk)

        row = 1
        r.check_disk_row(disk, row, "Partition", f"/dev/vdb{row}")
        r.check_disk_row(disk, row, "Format type", "xfs")
        r.check_disk_row(disk, row, "Mount point", "/home")

    def testEncryptedUnlock(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        m.add_disk(10)

        # BIOS boot partition, /boot partition, /
        disk1 = "/dev/vda"
        m.execute(f"""
        sgdisk --zap-all {disk1}
        sgdisk --new=0:0:+1MiB -t 0:ef02 {disk1}
        sgdisk --new=0:0:+1GiB {disk1}
        sgdisk --new=0:0:0 {disk1}
        mkfs.xfs {disk1}2
        mkfs.xfs {disk1}3
        """)


        disk2 = "vdb"
        m.execute(f"""
        sgdisk --zap-all /dev/{disk2}
        sgdisk --new=0:0 /dev/{disk2}
        echo einszweidrei | cryptsetup luksFormat /dev/{disk2}1
        echo einszweidrei | cryptsetup luksOpen /dev/{disk2}1 encrypted-vol
        mkfs.xfs /dev/mapper/encrypted-vol
        cryptsetup luksClose encrypted-vol
        """)
        self.udevadm_settle()

        partitions = {}
        partitions[disk1] = [f"{disk1}2", f"{disk1}3"]
        partitions[disk2] = [f"{disk2}1"]
        self.select_mountpoint(i, s, [disk1, disk2], partitions)

        self.unlock_device("1234", "Failed to unlock LUKS partition")

        b.click("#custom-mountpoint-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")
        self.unlock_device("einszweidrei")
        b.wait_not_present("#custom-mountpoint-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")

        self.check_partition(4, "/dev/mapper/luks")
        self.check_format_type(4, "xfs")

        self.select_from_dropdown(2, "boot", "/boot")
        self.select_from_dropdown(3, "root", "/")
        self.select_from_dropdown(4, "home", "/home")

        i.next()

        r.expand_disk_table(disk2)
        r.check_disk_row(disk2, 1, "Partition", "/dev/mapper/luks")

if __name__ == '__main__':
    test_main()
