#!/usr/bin/python3
#
# Copyright (C) 2022 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

import anacondalib
from installer import Installer
from password import Password
from progress import Progress
from review import Review
from storage import Storage
from storagelib import StorageCase, StorageHelpers  # pylint: disable=import-error
from testlib import nondestructive, skipImage, test_main  # pylint: disable=import-error
from users import dbus_reset_users


class TestStorage(anacondalib.VirtInstallMachineCase, StorageHelpers):
    efi = False

    def set_valid_password(self, password_ui, password="abcdefgh"):
        password_ui.set_password(password)
        password_ui.set_password_confirm(password)

    @nondestructive
    def testLocalStandardDisks(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        # Check the auto-selected disk's details
        s.check_single_disk_destination("vda", "16.1 GB")

        # Pixel test the storage step
        b.assert_pixels(
            "#app",
            "storage-step-basic",
            ignore=anacondalib.pixel_tests_ignore,
        )

        # This attaches a disk to the running VM
        # However, since the storage module initialization is long completed
        # the newly added disk, will not be visible in the UI,
        # until the test clicks on the re-scan button
        dev = self.add_ram_disk(2)
        dev = dev.split("/")[-1]
        s.rescan_disks()

        # Check the newly added disk generated a notification
        s.wait_disk_added(dev)

        # Check that the disk selection persists when moving next and back
        s.check_disk_selected("vda", True)
        i.next()
        i.back()
        s.check_disk_selected("vda", True)

        # Try unselecting the single disk and expect and error
        s.select_disk("vda", False)
        s.wait_no_disks()
        # Check the next button is disabled if no disks are selected
        i.check_next_disabled()

        # Check clear selection of disks
        s.select_disk(dev, True)
        s.select_disk("vda", True)
        s.select_none_disks_and_check([dev, "vda"])

    # Test moving back and forth between screens.
    # Disk initialization mode is applied to the backend in the test.
    # Partitioning is not applied to the backend in the test.
    def testAutopartitioningEncrypted(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)
        p = Password(b, s.encryption_id_prefix)
        pro = Progress(b)

        i.open()
        # Language selection

        i.reach(i.steps.INSTALLATION_METHOD)

        # Check the default mode
        s.check_partitioning_selected("erase-all")

        i.next()
        # Disk Encryption

        i.check_next_disabled(False)

        b.assert_pixels(
            "#app",
            "storage-step-encrypt",
            ignore=anacondalib.pixel_tests_ignore,
        )

        s.check_encryption_selected(False)
        encrypt = True
        s.set_encryption_selected(encrypt)

        # Disk Encryption / password screen
        b.assert_pixels(
            "#app",
            "storage-step-password",
            ignore=anacondalib.pixel_tests_ignore,
        )

        # No password set
        p.check_pw_rule("length", "indeterminate")
        p.check_pw_rule("match", "indeterminate")
        i.check_next_disabled()

        # Set pw which is too short
        p.set_password("abcd")
        p.check_pw_strength(None)
        i.check_next_disabled()
        p.check_pw_rule("length", "error")
        p.check_pw_rule("match", "error")

        # Make the pw 8 chars long
        p.set_password("efgh", append=True, value_check=False)
        i.check_next_disabled()
        p.check_password("abcdefgh")
        p.check_pw_rule("length", "success")
        p.check_pw_rule("match", "error")
        p.check_pw_strength("weak")

        # Non-ASCII password
        p.set_password(8 * "š")
        p.check_password(8 * "š")
        p.check_pw_rule("length", "success")
        p.check_pw_rule("match", "error")
        p.check_pw_rule("ascii", "warning")
        p.check_pw_strength("weak")

        # Valid ASCII password
        p.set_password("abcdefgh")
        p.check_password("abcdefgh")

        # Set the password confirm
        p.set_password_confirm("abcdefg")
        p.check_pw_rule("match", "error")
        p.set_password_confirm("abcdefgh")
        p.check_pw_rule("match", "success")
        p.check_pw_rule("length", "success")
        p.check_pw_strength("weak")
        p.check_password("abcdefgh")
        p.check_password_confirm("abcdefgh")
        i.check_next_disabled(disabled=False)

        # Check setting strong password
        strong_password = "Rwce82ybF7dXtCzFumanchu!!!!!!!!"
        p.set_password(strong_password)
        p.check_password(strong_password)
        p.check_pw_strength("strong")
        p.set_password_confirm(strong_password)

        # Reboot and check installed system
        i.reach(i.steps.REVIEW)
        i.begin_installation()
        pro.wait_done()
        s.unlock_storage_on_boot(strong_password)
        self.handleReboot()
        s.check_post_install_encryption_enabled()

    # Test moving back after partitioning is applied,
    # the partitioning should be reset.
    @nondestructive
    def testAutopartitioningReset(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)
        p = Password(b, s.encryption_id_prefix)

        i.open()

        i.reach(i.steps.INSTALLATION_METHOD)

        # Check the default mode
        s.check_partitioning_selected("erase-all")

        # Check that when an unpartitioned disk is selected the "Use free space" scenario is hidden
        s.wait_scenario_visible("use-free-space", False)

        # Check that when a partitioned disk is selected the "Use free space" scenario is visible
        s.add_basic_partitioning()
        s.wait_scenario_visible("use-free-space")

        s.set_partitioning("use-free-space")

        i.next()
        # Disk Encryption / password screen

        encrypt = True
        s.set_encryption_selected(encrypt)
        s.check_encryption_selected(encrypt)

        # Set valid password
        self.set_valid_password(p)

        # Verify that the password is saved when moving forward and back
        i.next()
        i.back()
        p.check_password("abcdefgh")
        p.check_password_confirm("abcdefgh")

        i.back()
        # Storage Configuration
        # The choice is preserved (stored in the backend).
        # The choice is available only if the partitioning was reset
        # (there is enough free space)
        s.check_partitioning_selected("use-free-space")

        i.next()
        # The value is preserved
        s.check_encryption_selected(encrypt)

    @nondestructive
    def testPartitioningObject(self):
        # Test which partitioning object ends up being the AppliedPartitioning
        # when we go back and forward the storage steps

        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        self.addCleanup(s.dbus_reset_partitioning)

        # Read partitioning data before we do anything
        created_partitioning = s.dbus_get_created_partitioning()

        # Go to Review step
        i.open()
        self.addCleanup(lambda: dbus_reset_users(self.machine))
        i.reach(i.steps.REVIEW)

        # Read partitioning data after we went to Review step
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        new_created_partitioning = s.dbus_get_created_partitioning()

        # A new AUTOMATIC partitioning object should be created each time the user enters the review page
        self.assertEqual(len(created_partitioning) + 1, len(new_created_partitioning))
        # The applied partitioning object should be the last one created
        self.assertEqual(new_applied_partitioning, new_created_partitioning[-1])

        created_partitioning = new_created_partitioning

        # Create a few partitioning objects and ensure that these will not mess up with the user's
        # configuration
        for _ in range(10):
            s.dbus_create_partitioning("AUTOMATIC")

        # Go back to the Disk Configuration page and re-enter the review screen.
        # This should create again a new partitioning object and apply it
        # no matter how many partitioning objects were created before
        i.reach_on_sidebar(i.steps.DISK_ENCRYPTION)
        i.reach(i.steps.REVIEW)
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        new_created_partitioning = s.dbus_get_created_partitioning()

        self.assertEqual(len(created_partitioning) + 11, len(new_created_partitioning))
        self.assertEqual(new_applied_partitioning, new_created_partitioning[-1])

        # The applied partitioning should be reset also when going back to installation method
        i.click_step_on_sidebar(i.steps.INSTALLATION_METHOD)
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        self.assertEqual(new_applied_partitioning, "")

    def testCockpitJsErrorHandling(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        # Clean up the journal before we open Report dialog
        # (Report dialog presents all journal in a textarea)
        # to avoid crashing the test browser
        m.execute("journalctl --rotate; journalctl --vacuum-time=1s")

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.modify_storage()
        b.wait_visible(".cockpit-storage-integration-sidebar")
        b._wait_present("iframe[name='cockpit-storage']")
        b.switch_to_frame("cockpit-storage")
        b._wait_present("#storage.ct-page-fill")

        b.wait_not_present("#critical-error-bz-report-modal.pf-v5-c-modal-box")

        with self.assertRaises(RuntimeError):
            b.eval_js("window.setTimeout(function() {throw new Error('Unexpected storage JS error')}, 0);")
            b.wait_in_text("#critical-error-bz-report-modal-details", "Unexpected storage JS error")
            b.wait_in_text("#critical-error-bz-report-modal header", "The installer cannot continue due to a critical error: Storage plugin failed")


# TODO add next back test keeping the choice
@nondestructive
class TestStorageExtraDisks(anacondalib.VirtInstallMachineCase, StorageHelpers):
    efi = False

    def testLocalDisksSyncNew(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        # This attaches a disk to the running VM
        # However, since the storage module initialization is long completed
        # the newly added disk, will not be visible in the UI,
        # until the test clicks on the re-scan button
        dev = self.add_ram_disk(2)
        dev = dev.split("/")[-1]

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        s.wait_no_disks_detected_not_present()

        s.check_single_disk_destination("vda")

        s.rescan_disks()

        s.check_disk_visible("vda")
        s.check_disk_visible(dev)

        s.wait_no_disks_detected_not_present()

        s.check_disk_selected("vda", True)
        s.check_disk_selected(dev, False)

        s.rescan_disks()

        s.check_disk_selected("vda", True)
        s.check_disk_selected(dev, False)

        s.select_disk(dev)

        # Check that disk selection is kept on Next and Back
        i.next()
        i.back()
        for disk in ["vda", dev]:
            s.check_disk_selected(disk)


class TestStorageMountPoints(anacondalib.VirtInstallMachineCase, StorageCase):
    efi = False

    @nondestructive
    @skipImage("btrfs support missing on fedora-eln image", "fedora-eln-boot")
    def testBasic(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        disk = "/dev/vda"
        dev = "vda"
        btrfsname = "btrfstest"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("10GiB", "btrfs", "-f", "-L", btrfsname), ("", "xfs")])

        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        s.select_mountpoint([(dev, True)])

        # verify gathered requests
        # root partition is not auto-mapped
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.select_mountpoint_row_device(1, "btrfstest")
        s.check_mountpoint_row_format_type(1, "btrfs")

        s.check_mountpoint_row(2, "/boot", "Select a device", False)
        s.select_mountpoint_row_device(2, f"{dev}2")
        s.check_mountpoint_row_format_type(2, "ext4")

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(3, f"{dev}4")
        s.check_mountpoint_row_reformat(3, False)
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.check_mountpoint_row_format_type(3, "xfs")

        # Toggle reformat option
        s.select_mountpoint_row_reformat(2)
        s.check_mountpoint_row_reformat(2, True)

        b.assert_pixels(
            "#app",
            "mount-point-mapping-table",
            ignore=anacondalib.pixel_tests_ignore,
        )

        self.addCleanup(lambda: dbus_reset_users(self.machine))
        i.reach(i.steps.REVIEW)

        # verify review screen
        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, "vda2, 1.07 GB: format as ext4, /boot")
        r.check_disk_row(dev, "btrfstest, 10.7 GB: format as btrfs, /")
        r.check_disk_row(dev, "vda4, 4.29 GB: mount, /home")

        applied_partitioning = s.dbus_get_applied_partitioning()

        # When adding a new partition a new partitioning should be created
        i.reach_on_sidebar(i.steps.INSTALLATION_METHOD)

        m.execute(f"sgdisk --new=0:0:0 {disk}")
        s.rescan_disks()
        s.select_mountpoint([(dev, True)])
        s.check_mountpoint_row_device(1, "Select a device")
        s.check_mountpoint_row_device(2, "Select a device")
        s.select_mountpoint_row_device(1, f"{dev}2")
        s.select_mountpoint_row_device(2, "btrfstest")

        i.next()
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        self.assertNotEqual(new_applied_partitioning, applied_partitioning)

        # When going back and forward 'Next' button should not be disabled
        # https://bugzilla.redhat.com/show_bug.cgi?id=2242086
        i.back(previous_page=i.steps.CUSTOM_MOUNT_POINT)
        i.check_next_disabled(False)

        # Swap partitions should not be selectable for the required mount point rows
        # https://bugzilla.redhat.com/show_bug.cgi?id=2239836
        i.back()

        m.execute(f"mkswap {disk}5")
        s.rescan_disks()
        s.select_mountpoint([(dev, True)])
        s.check_mountpoint_row_device_available(1, f"{dev}5", True, True)

    @nondestructive
    def testNoRootMountPoint(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        # BIOS boot /boot on ext4 / on xfs /home on btrfs
        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("10GiB", "xfs"), ("", "ext4")])
        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        s.select_mountpoint([(dev, True)])

        # verify gathered requests
        s.select_mountpoint_row_device(2, f"{dev}2")
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.check_mountpoint_row(2, "/boot", f"{dev}2", False, "ext4")

        # Test moving back and forth between screens.
        i.back()
        i.next(next_page=i.steps.CUSTOM_MOUNT_POINT)
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.check_mountpoint_row(2, "/boot", f"{dev}2", False, "ext4")

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(3, f"{dev}4")
        s.check_mountpoint_row_format_type(3, "ext4")
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.check_mountpoint_row_reformat(3, False)

        i.check_next_disabled()

    def testMultipleDisks(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        m.add_disk(10)

        # BIOS boot partition, /boot partition, /
        disk1 = "/dev/vda"
        dev1 = "vda"
        s.partition_disk(disk1, [("1MiB", "biosboot"), ("1GB", "xfs"), ("", "xfs")])

        # /dev/vdb1 /home partition
        disk2 = "/dev/vdb"
        dev2 = "vdb"
        s.partition_disk(disk2, [("", "xfs")])
        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        s.rescan_disks()

        # Select only vdb disk and verify that mount point assignment is
        # not available (missing biosboot)
        s.select_none_disks_and_check([dev1, dev2])
        s.select_disks([(dev1, False), (dev2, True)])
        s.wait_scenario_available("mount-point-mapping", False)

        # Select only vda disk and verify that the partitioning request is correct
        s.select_none_disks_and_check([dev1, dev2])
        s.select_mountpoint([(dev1, True), (dev2, False)])

        s.check_mountpoint_row_device_available(1, "vdb1", False)
        s.check_mountpoint_row_device_available(1, "vda2")

        # Go back and change the disk selection. The partitioning should be re-created
        i.back()

        s.select_none_disks_and_check([dev1, dev2])
        s.select_mountpoint([(dev1, True), (dev2, True)])

        s.check_mountpoint_row_device_available(1, "vda2", True)
        s.check_mountpoint_row_device_available(1, "vdb1")

        s.select_mountpoint_row_device(1, f"{dev1}3")
        s.check_mountpoint_row(1, "/", f"{dev1}3", True, "xfs")

        s.select_mountpoint_row_device(2, f"{dev1}2")
        s.check_mountpoint_row(2, "/boot", f"{dev1}2", False, "xfs")

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(3, f"{dev2}1")
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.check_mountpoint_row(3, "/home", f"{dev2}1", False, "xfs")

        self.addCleanup(lambda: dbus_reset_users(self.machine))
        i.reach(i.steps.REVIEW)

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (0x1af4)")
        r.check_disk_row(disk, "vda2, 1.07 GB: mount, /boot")
        r.check_disk_row(disk, "vda3, 15.0 GB: format as xfs, /")

        disk = "vdb"
        r.check_disk(disk, "10.7 GB vdb (0x1af4)")
        r.check_disk_row(disk, "vdb1, 10.7 GB: mount, /home")

        b.assert_pixels(
            "#app",
            "review-multiple-disks",
            ignore=anacondalib.pixel_tests_ignore,
        )

    @nondestructive
    def testEncryptedUnlock(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        disk1 = "/dev/vda"
        dev1 = "vda"
        s.partition_disk(
            disk1,
            [("1MiB", "biosboot"), ("1GB", "xfs"), ("1GB", "xfs"), ("1GB", "xfs"), ("", "xfs")]
        )
        m.execute(f"""
        echo einszwei | cryptsetup luksFormat {disk1}2
        echo einszwei | cryptsetup luksOpen {disk1}2 encrypted-vol0
        mkfs.xfs -f /dev/mapper/encrypted-vol0
        cryptsetup luksClose encrypted-vol0
        echo einszweidrei | cryptsetup luksFormat {disk1}3
        echo einszweidrei | cryptsetup luksOpen {disk1}3 encrypted-vol1
        mkfs.xfs -f /dev/mapper/encrypted-vol1
        cryptsetup luksClose encrypted-vol1
        echo einszweidreivier | cryptsetup luksFormat {disk1}4
        echo einszweidreivier | cryptsetup luksOpen {disk1}4 encrypted-vol2
        mkfs.xfs -f /dev/mapper/encrypted-vol2
        cryptsetup luksClose encrypted-vol2
        """)
        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        s.select_mountpoint([(dev1, True)], encrypted=True)

        s.unlock_all_encrypted()
        s.unlock_device("1234", ["vda2", "vda3", "vda4"], [])
        b.click("#unlock-device-dialog-close-btn")

        # The 'Skip' button closes the dialog
        s.unlock_all_encrypted_skip()
        b.wait_not_present("button:contains(Unlock)")

        i.back()
        i.next(next_page=i.steps.CUSTOM_MOUNT_POINT)

        s.unlock_all_encrypted()
        s.unlock_device("einszwei", ["vda2", "vda3", "vda4"], ["vda2"])

        # The 'Unlock' dialog should stay open unless all LUKS devices are unlocked
        s.unlock_device("einszweidrei", ["vda3", "vda4"], ["vda3"])

        # The 'Unlock' dialog closes when all LUKS devices are unlocked
        s.unlock_device("einszweidreivier", ["vda4"], ["vda4"])
        b.wait_not_present("#mount-point-mapping-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")

        self._testEncryptedUnlock(b, m)

    def _testEncryptedUnlock(self, b, m):
        dev1 = "vda"

        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        s.check_mountpoint_row_mountpoint(2, "/boot")
        s.select_mountpoint_row_device(2, "vda5")

        s.check_mountpoint_row_mountpoint(1, "/")
        selector = "#mount-point-mapping-table-row-1 .pf-v5-c-select__toggle"
        b.click(f"{selector}:not([disabled]):not([aria-disabled=true])")
        select_entry = f"{selector} + ul li:nth-of-type(3) button"
        b.click(select_entry)
        b.wait_in_text(f"{selector} .pf-v5-c-select__toggle-text", "luks")
        s.check_mountpoint_row_format_type(1, "xfs")

        self.addCleanup(lambda: dbus_reset_users(m))
        i.reach(i.steps.REVIEW)

        r.check_in_disk_row(dev1, 2, "luks-")

    def testEncryptedUnlockCockpit(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        _r = Review(b, m)  # noqa: F841

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.check_single_disk_destination("vda")

        s.modify_storage()
        b.wait_visible(".cockpit-storage-integration-sidebar")
        s.check_constraint("/", True)
        s.check_constraint("biosboot", True)
        s.check_constraint("/boot", False)

        frame = "iframe[name='cockpit-storage']"
        b._wait_present(frame)
        b.switch_to_frame("cockpit-storage")
        b._wait_present("#storage.ct-page-fill")

        self.click_dropdown(self.card_row("Storage", 1), "Create partition table")
        self.confirm()

        self.click_dropdown(self.card_row("Storage", 2), "Create partition")
        self.dialog({"size": 1, "type": "biosboot"})

        self.click_dropdown(self.card_row("Storage", 3), "Create partition")
        self.dialog({
            "size": 1000,
            "type": "xfs",
            "crypto": self.default_crypto_type,
            "passphrase": "einszwei",
            "passphrase2": "einszwei",
        })

        self.click_dropdown(self.card_row("Storage", 4), "Create partition")
        self.dialog({
            "size": 1000,
            "type": "xfs",
            "crypto": self.default_crypto_type,
            "passphrase": "einszweidrei",
            "passphrase2": "einszweidrei",
        })

        self.click_dropdown(self.card_row("Storage", 5), "Create partition")
        self.dialog({
            "size": 1000,
            "type": "xfs",
            "crypto": self.default_crypto_type,
            "passphrase": "einszweidreivier",
            "passphrase2": "einszweidreivier",
        })

        self.click_dropdown(self.card_row("Storage", 6), "Create partition")
        self.dialog({"size": 1000, "type": "ext4"})

        # Exit the cockpit-storage iframe
        b.switch_to_top()
        s.return_to_installation()
        s.return_to_installation_confirm()
        i.wait_current_page(i.steps.INSTALLATION_METHOD)

        s.select_mountpoint([("vda", True)])

        self._testEncryptedUnlock(b, m)

    @nondestructive
    def testEncryptedUnlockRAIDonLUKS(self):
        # RAID on LUKS: partition -> LUKS -> RAID -> filesystem
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        # BIOS boot partition, /boot partition, / on RAID
        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "xfs"), ("5GB", None), ("5GB", None)])
        m.execute(f"""
        echo einszweidrei | cryptsetup luksFormat {disk}3
        echo einszweidrei | cryptsetup luksOpen {disk}3 encrypted-vol
        echo einszweidrei | cryptsetup luksFormat {disk}4
        echo einszweidrei | cryptsetup luksOpen {disk}4 encrypted-vol2
        mdadm --create --run encryptedraid --level=raid1 --raid-devices=2 /dev/mapper/encrypted-vol /dev/mapper/encrypted-vol2
        mkfs.xfs /dev/md/encryptedraid
        """)
        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        # select only vda and check that we don't try to unlock the LUKS partition on vdb
        s.select_mountpoint([(dev, True)], encrypted=True)

        s.unlock_all_encrypted()
        s.unlock_device("einszweidrei", ["vda3", "vda4"], ["vda3", "vda4"])
        b.wait_not_present("#mount-point-mapping-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")

        s.select_mountpoint_row_device(1, "encryptedraid")
        s.check_mountpoint_row_format_type(1, "xfs")

        s.check_mountpoint_row_mountpoint(2, "/boot")
        s.select_mountpoint_row_device(2, f"{dev}2")
        s.select_mountpoint_row_reformat(2)
        s.check_mountpoint_row_reformat(2, True)

        self.addCleanup(lambda: dbus_reset_users(self.machine))
        i.reach(i.steps.REVIEW)

        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, "vda2, 1.07 GB: format as xfs, /boot")
        r.check_disk_row(dev, "encryptedraid, 5.35 GB: format as xfs, /")

    def testEncryptedUnlockLUKSonRAID(self):
        # LUKS on RAID: partition -> RAID -> LUKS -> filesystem
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        # BIOS boot partition, /boot partition, / on RAID
        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "xfs"), ("5GB", None), ("5GB", None)])
        m.execute(f"""
        mdadm --create --run encryptedraid --level=raid1 --raid-devices=2 {disk}3 {disk}4
        echo einszweidrei | cryptsetup luksFormat /dev/md/encryptedraid
        echo einszweidrei | cryptsetup luksOpen /dev/md/encryptedraid encrypted-vol
        mkfs.xfs /dev/mapper/encrypted-vol
        cryptsetup luksClose /dev/mapper/encrypted-vol
        """)
        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        # select only vda and check that we don't try to unlock the LUKS partition on vdb
        s.select_mountpoint([(dev, True)], encrypted=True)

        s.unlock_all_encrypted()
        s.unlock_device("einszweidrei", ["encryptedraid"], ["encryptedraid"])
        b.wait_not_present("#mount-point-mapping-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")

        s.check_mountpoint_row_mountpoint(2, "/boot")
        s.select_mountpoint_row_device(2, f"{dev}2")
        s.select_mountpoint_row_reformat(2)
        s.check_mountpoint_row_reformat(2, True)

        s.check_mountpoint_row_mountpoint(1, "/")
        selector = "#mount-point-mapping-table-row-1 .pf-v5-c-select__toggle"
        b.click(f"{selector}:not([disabled]):not([aria-disabled=true])")
        select_entry = f"{selector} + ul li:nth-of-type(2) button"
        b.click(select_entry)
        b.wait_in_text(f"{selector} .pf-v5-c-select__toggle-text", "luks")
        s.check_mountpoint_row_format_type(1, "xfs")

        self.addCleanup(lambda: dbus_reset_users(self.machine))
        i.reach(i.steps.REVIEW)

        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_in_disk_row(dev, 2, "luks-")

    @nondestructive
    @skipImage("btrfs support missing on fedora-eln image", "fedora-eln-boot")
    def testBtrfsSubvolumes(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        disk = "/dev/vda"
        dev = "vda"
        tmp_mount = "/tmp/btrfs-mount-test"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("", "btrfs")])
        m.execute(f"""
        mkdir -p {tmp_mount}
        mount {disk}3 {tmp_mount}
        btrfs subvolume create {tmp_mount}/root
        btrfs subvolume create {tmp_mount}/home
        btrfs subvolume create {tmp_mount}/unused
        btrfs subvolume snapshot {tmp_mount}/root {tmp_mount}/snapshot1
        umount {tmp_mount}
        rmdir {tmp_mount}
        """)

        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        s.select_mountpoint([(dev, True)])

        # btrfs snapshots should not be available
        s.check_mountpoint_row_device_available(1, "snapshot1", False)

        # verify gathered requests
        # root partition is not auto-mapped
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.select_mountpoint_row_device(1, "root")
        s.check_mountpoint_row_format_type(1, "btrfs")

        s.check_mountpoint_row(2, "/boot", "Select a device", False)
        s.select_mountpoint_row_device(2, f"{dev}2")
        s.check_mountpoint_row_format_type(2, "ext4")

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(3, "home")
        s.check_mountpoint_row_reformat(3, False)
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.check_mountpoint_row_format_type(3, "btrfs")

        # Toggle reformat option
        s.select_mountpoint_row_reformat(2)
        s.check_mountpoint_row_reformat(2, True)

        self.addCleanup(lambda: dbus_reset_users(self.machine))
        i.reach(i.steps.REVIEW)

        # verify review screen
        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, "vda2, 1.07 GB: format as ext4, /boot")
        r.check_disk_row(dev, "root, 15.0 GB: format as btrfs, /")
        r.check_disk_row(dev, "home, 15.0 GB: mount, /home")
        r.check_disk_row_not_present(dev, "unused")

        i.reach_on_sidebar(i.steps.INSTALLATION_METHOD)

        # Checks for nested btrfs subvolume
        tmp_mount = "/tmp/btrfs-mount-test"
        m.execute(f"""
        mkdir -p {tmp_mount}
        mount {disk}3 {tmp_mount}
        btrfs subvolume create {tmp_mount}/home/Movies
        btrfs subvolume create {tmp_mount}/home/Movies/Good_Movies
        btrfs subvolume create {tmp_mount}/home/Movies/Bad_Movies
        umount {tmp_mount}
        rmdir {tmp_mount}
        """)
        s.rescan_disks()
        s.select_mountpoint([(dev, True)])

        s.select_mountpoint_row_device(1, "root")
        s.select_mountpoint_row_device(2, f"{dev}2")
        s.add_mountpoint_row()
        s.select_mountpoint_row_device(3, "home")
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.add_mountpoint_row()
        s.select_mountpoint_row_device(4, "home/Movies")
        s.select_mountpoint_row_mountpoint(4, "/home/Movies")
        s.add_mountpoint_row()
        s.select_mountpoint_row_device(5, "home/Movies/Good_Movies")
        s.select_mountpoint_row_mountpoint(5, "/home/Movies/Good_Movies")
        s.add_mountpoint_row()
        s.select_mountpoint_row_device(6, "home/Movies/Bad_Movies")
        s.select_mountpoint_row_mountpoint(6, "/home/Movies/Bad_Movies")

        # No error when no devices are reformatted
        for row in range(3, 6):
            s.wait_mountpoint_table_column_helper(row, "format", present=False)

        # When parent is re-formatted all child devices must be reformatted
        s.select_mountpoint_row_device(4, "home/Movies")
        s.select_mountpoint_row_reformat(4)
        s.wait_mountpoint_table_column_helper(4, "format", text="Mismatch")
        s.select_mountpoint_row_reformat(5)
        s.select_mountpoint_row_reformat(6)
        s.wait_mountpoint_table_column_helper(4, "format", present=False)

        # Check also that the rules apply to children deeper in the device tree
        s.select_mountpoint_row_reformat(3)
        s.wait_mountpoint_table_column_helper(3, "format", present=False)
        s.select_mountpoint_row_reformat(6, False)
        s.wait_mountpoint_table_column_helper(3, "format", text="Mismatch")

        # When parent is re-formmated all child devices should be
        # * either also reformatted if selected
        # * either not selected (not part of the mountpoint assignment table)
        s.remove_mountpoint_row(5, 6)
        s.remove_mountpoint_row(5, 5)
        s.wait_mountpoint_table_column_helper(3, "format", present=False)
        s.wait_mountpoint_table_column_helper(4, "format", present=False)

        i.check_next_disabled(False)

    @skipImage("btrfs support missing on fedora-eln image", "fedora-eln-boot")
    def testUnsupportedStorageConfiguration(self):
        # Prevent the user from performing an installation if multiple devices exist with the same name
        # https://bugzilla.redhat.com/show_bug.cgi?id=2237878
        # TODO: Make the test nondestructive
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        _r = Review(b, m)  # noqa: F841

        disk = "/dev/vda"
        tmp_mount = "/tmp/btrfs-mount-test"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "btrfs"), ("", "btrfs")])
        m.execute(f"""
        mkdir -p {tmp_mount}

        mount {disk}2 {tmp_mount}
        btrfs subvolume create {tmp_mount}/home
        umount {tmp_mount}

        mount {disk}3 {tmp_mount}
        btrfs subvolume create {tmp_mount}/home
        umount {tmp_mount}
        rmdir {tmp_mount}
        """)

        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()
        s.wait_scenario_available("mount-point-mapping", False)

    @nondestructive
    def testLVM(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        vgname = "fedoravg"

        self.addCleanup(m.execute, f"vgremove -y -ff {vgname}")

        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("", None)])
        m.execute(f"""
        vgcreate -y -f {vgname} {disk}3
        lvcreate -y -l40%FREE -n root {vgname}
        mkfs.ext4 -F /dev/{vgname}/root
        lvcreate -y -l90%FREE -n home {vgname}
        mkfs.ext4 -F /dev/{vgname}/home
        lvcreate -y -l100%FREE -n swap {vgname}
        mkswap /dev/{vgname}/swap
        """)

        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        s.select_mountpoint([(dev, True)])

        # verify gathered requests
        # root partition is not auto-mapped
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.check_mountpoint_row(2, "/boot", "Select a device", False)

        s.select_mountpoint_row_device(1, f"{vgname}-root")
        s.check_mountpoint_row(1, "/", f"{vgname}-root", True, "ext4")

        s.select_mountpoint_row_device(2, f"{dev}2")
        s.check_mountpoint_row(2, "/boot", f"{dev}2", False, "ext4")

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(3, f"{vgname}-home")
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.check_mountpoint_row(3, "/home", f"{vgname}-home", False, "ext4")

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(4, f"{vgname}-swap")
        s.check_mountpoint_row(4, "swap", f"{vgname}-swap", False, "swap")

        # Toggle reformat option
        s.select_mountpoint_row_reformat(2)
        s.check_mountpoint_row_reformat(2, True)

        self.addCleanup(lambda: dbus_reset_users(self.machine))
        i.reach(i.steps.REVIEW)

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (0x1af4)")

        r.check_disk_row(disk, "vda2, 1.07 GB: format as ext4, /boot")
        r.check_disk_row(disk, f"{vgname}-root, 6.01 GB: format as ext4, /")
        r.check_disk_row(disk, f"{vgname}-home, 8.12 GB: mount, /home")
        r.check_disk_row(disk, f"{vgname}-swap, 902 MB: mount, swap")

        i.reach_on_sidebar(i.steps.CUSTOM_MOUNT_POINT)

        # remove the /home row and check that row 3 is now swap
        s.remove_mountpoint_row(3, 4)

        s.check_mountpoint_row_mountpoint(3, "swap")
        s.check_mountpoint_row_device(3, f"{vgname}-swap")

        i.reach(i.steps.REVIEW)

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (0x1af4)")

        r.check_disk_row(disk, "vda2, 1.07 GB: mount, /boot")
        r.check_disk_row(disk, f"{vgname}-root, 6.01 GB: format as ext4, /")
        r.check_disk_row(disk, f"{vgname}-swap, 902 MB: mount, swap")

    @nondestructive
    def testUnusableFormats(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("1GB", None), ("1GB", "lvmpv")])
        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        s.select_mountpoint([(dev, True)])

        # unformatted and unmountable devices should not be available
        s.check_mountpoint_row_device_available(1, f"{dev}3", False)
        s.check_mountpoint_row_device_available(1, f"{dev}4", False)


class TestStorageCockpitIntegration(anacondalib.VirtInstallMachineCase, StorageCase):
    @nondestructive
    def testEncryptedUnlock(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m, scenario="use-configured-storage")
        s = Storage(b, m)
        r = Review(b, m)

        dev = "vda"

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.wait_scenario_visible("use-configured-storage", False)
        s.check_single_disk_destination("vda")
        s.modify_storage()
        b.wait_visible(".cockpit-storage-integration-sidebar")

        frame = "iframe[name='cockpit-storage']"
        b._wait_present(frame)
        b.switch_to_frame("cockpit-storage")
        b._wait_present("#storage.ct-page-fill")

        self.click_dropdown(self.card_row("Storage", 1), "Create partition table")
        # Pixel test the cockpit storage view, modal backdrops should cover the whole screen
        b.switch_to_top()
        b.assert_pixels(
            "#app",
            "storage-editor",
            ignore=[*anacondalib.pixel_tests_ignore, ".cockpit-storage-integration-requirements-hint"],
        )
        b.switch_to_frame("cockpit-storage")
        self.confirm()

        self.click_dropdown(self.card_row("Storage", 2), "Create partition")
        self.dialog({"size": 1, "type": "biosboot"})

        self.click_dropdown(self.card_row("Storage", 3), "Create partition")
        self.dialog({"size": 1070, "type": "ext4", "mount_point": "/boot"})

        self.click_dropdown(self.card_row("Storage", 4), "Create partition")
        self.dialog({
            "type": "ext4", "mount_point": "/",
            "crypto": self.default_crypto_type,
            "passphrase": "redhat",
            "passphrase2": "redhat",
        })

        # Exit the cockpit-storage iframe
        b.switch_to_top()

        s.return_to_installation()
        s.return_to_installation_confirm()

        s.check_partitioning_selected("use-configured-storage")

        # Check that choosing another storage scenario without diving into that,
        # preserves the visibility of "Use configured storage"
        s.set_partitioning("erase-all")
        s.wait_scenario_available("use-configured-storage")

        s.set_partitioning("use-configured-storage")

        self.addCleanup(lambda: dbus_reset_users(m))
        i.reach(i.steps.REVIEW)

        r.check_in_disk_row(dev, 2, "luks-")

    @nondestructive
    def testLVM(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m, scenario="use-configured-storage")
        s = Storage(b, m)
        r = Review(b, m)

        vgname = "fedoravg"

        self.addCleanup(m.execute, f"vgremove -y -ff {vgname}")

        dev = "vda"

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.wait_scenario_visible("use-configured-storage", False)
        s.check_single_disk_destination("vda")
        s.modify_storage()
        b.wait_visible(".cockpit-storage-integration-sidebar")

        frame = "iframe[name='cockpit-storage']"
        b._wait_present(frame)
        b.switch_to_frame("cockpit-storage")
        b._wait_present("#storage.ct-page-fill")

        self.click_dropdown(self.card_row("Storage", 1), "Create partition table")
        self.confirm()

        self.click_dropdown(self.card_row("Storage", 2), "Create partition")
        self.dialog({"size": 1, "type": "biosboot"})

        self.click_dropdown(self.card_row("Storage", 3), "Create partition")
        self.dialog({"size": 1070, "type": "ext4", "mount_point": "/boot"})

        self.click_devices_dropdown("Create LVM2 volume group")
        self.dialog({"name": vgname, "disks": {dev: True}})

        self.click_card_row("Storage", name=vgname)

        b.click(self.card_button("LVM2 logical volumes", "Create new logical volume"))
        self.dialog({"name": "root", "size": 6010})
        self.click_card_row("LVM2 logical volumes", 1)
        self.click_card_dropdown("Unformatted data", "Format")
        self.dialog({"type": "ext4", "mount_point": "/"})

        b.click(self.card_parent_link())

        b.click(self.card_button("LVM2 logical volumes", "Create new logical volume"))
        self.dialog({"name": "home", "size": 8120})
        self.click_card_row("LVM2 logical volumes", 1)
        self.click_card_dropdown("Unformatted data", "Format")
        self.dialog({"type": "ext4", "mount_point": "/home"})

        b.click(self.card_parent_link())

        b.click(self.card_button("LVM2 logical volumes", "Create new logical volume"))
        self.dialog({"name": "swap", "size": 898})
        self.click_card_row("LVM2 logical volumes", 3)
        self.click_card_dropdown("Unformatted data", "Format")
        self.dialog({"type": "swap"})

        # Exit the cockpit-storage iframe
        b.switch_to_top()

        def checkStorageReview():
            disk = "vda"
            r.check_disk(disk, "16.1 GB vda (0x1af4)")
            r.check_disk_row(disk, "vda2, 1.07 GB: mount, /boot")
            r.check_disk_row(disk, f"{vgname}-root, 6.01 GB: mount, /")
            r.check_disk_row(disk, f"{vgname}-home, 8.12 GB: mount, /home")
            r.check_disk_row(disk, f"{vgname}-swap, 898 MB: mount, swap")

        s.return_to_installation()

        # verify storage layout review in Cockpit storage exit dialog
        checkStorageReview()
        b.assert_pixels(
            "#cockpit-storage-integration-check-storage-dialog",
            "cockpit-storage-integration-check-storage-dialog-LVM",
            ignore=anacondalib.pixel_tests_ignore,
        )
        s.return_to_installation_confirm()

        s.set_partitioning("use-configured-storage")

        self.addCleanup(lambda: dbus_reset_users(m))
        i.reach(i.steps.REVIEW)

        # verify review screen
        checkStorageReview()

    @nondestructive
    def testBtrfsSubvolumes(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m, scenario="use-configured-storage")
        s = Storage(b, m)
        r = Review(b, m)

        tmp_mount = "/btrfs-mount-test"

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.wait_scenario_visible("use-configured-storage", False)
        s.check_single_disk_destination("vda")
        s.modify_storage()
        b.wait_visible(".cockpit-storage-integration-sidebar")

        frame = "iframe[name='cockpit-storage']"
        b._wait_present(frame)
        b.switch_to_frame("cockpit-storage")
        b._wait_present("#storage.ct-page-fill")

        self.click_dropdown(self.card_row("Storage", 1), "Create partition table")
        self.confirm()

        self.click_dropdown(self.card_row("Storage", 2), "Create partition")
        self.dialog({"size": 1, "type": "biosboot"})

        self.click_dropdown(self.card_row("Storage", 3), "Create partition")
        self.dialog({"size": 1070, "type": "ext4", "mount_point": "/boot"})

        self.click_dropdown(self.card_row("Storage", 4), "Create partition")
        self.dialog({"type": "btrfs"})

        self.click_card_row("Storage", name="/")

        b.click(self.card_button("btrfs subvolume", "Mount"))
        self.dialog({"mount_point": tmp_mount})

        b.click(self.card_button("btrfs subvolume", "Create subvolume"))
        self.dialog({"name": "root", "mount_point": "/"})

        b.click(self.card_button("btrfs subvolume", "Create subvolume"))
        self.dialog({"name": "unused"})

        b.click(self.card_button("btrfs subvolume", "Create subvolume"))
        self.dialog({"name": "home", "mount_point": "/home"})

        # Exit the cockpit-storage iframe
        b.switch_to_top()

        s.return_to_installation()
        s.return_to_installation_confirm()

        s.set_partitioning("use-configured-storage")

        self.addCleanup(lambda: dbus_reset_users(m))
        i.reach(i.steps.REVIEW)

        # verify review screen
        dev = "vda"
        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, "vda2, 1.07 GB: mount, /boot")
        r.check_disk_row(dev, "root, 15.0 GB: mount, /")
        r.check_disk_row(dev, "home, 15.0 GB: mount, /home")

        # Check fstab
        fstab = m.execute("cat /etc/fstab")
        self.assertTrue("/mnt/sysroot/boot auto noauto 0 0" in fstab)
        self.assertTrue("/mnt/sysroot/btrfs-mount-test auto subvol=/ 0 0" in fstab)
        self.assertTrue("/mnt/sysroot btrfs noauto,subvol=root 0 0" in fstab)
        self.assertTrue("/mnt/sysroot/home btrfs noauto,subvol=home 0 0" in fstab)

    @nondestructive
    def testBtrfsAndMountPointAssignment(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m, scenario="use-configured-storage")
        s = Storage(b, m)
        r = Review(b, m)

        tmp_mount = "/btrfs-mount-test"

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.wait_scenario_visible("use-configured-storage", False)
        s.check_single_disk_destination("vda")
        s.modify_storage()
        b.wait_visible(".cockpit-storage-integration-sidebar")

        frame = "iframe[name='cockpit-storage']"
        b._wait_present(frame)
        b.switch_to_frame("cockpit-storage")
        b._wait_present("#storage.ct-page-fill")

        self.click_dropdown(self.card_row("Storage", 1), "Create partition table")
        self.confirm()

        self.click_dropdown(self.card_row("Storage", 2), "Create partition")
        self.dialog({"size": 1, "type": "biosboot"})

        self.click_dropdown(self.card_row("Storage", 3), "Create partition")
        self.dialog({"size": 1070, "type": "ext4", "mount_point": "/boot"})

        self.click_dropdown(self.card_row("Storage", 4), "Create partition")
        self.dialog({"type": "btrfs"})

        self.click_card_row("Storage", name="/")

        b.click(self.card_button("btrfs subvolume", "Mount"))
        self.dialog({"mount_point": tmp_mount})

        b.click(self.card_button("btrfs subvolume", "Create subvolume"))
        self.dialog({"name": "root", "mount_point": "/"})

        b.click(self.card_button("btrfs subvolume", "Create subvolume"))
        self.dialog({"name": "unused"})

        b.click(self.card_button("btrfs subvolume", "Create subvolume"))
        self.dialog({"name": "home", "mount_point": "/home"})

        # Exit the cockpit-storage iframe
        b.switch_to_top()

        s.return_to_installation()
        s.return_to_installation_confirm()

        s.set_partitioning("mount-point-mapping")

        i.next(next_page=i.steps.CUSTOM_MOUNT_POINT)

        s.check_mountpoint_row(1, "/", "root", True, "btrfs")
        s.check_mountpoint_row(2, "/boot", "vda2", False, "ext4")
        s.check_mountpoint_row(3, "/home", "home", False, "btrfs")

        s.select_mountpoint_row_reformat(1)
        s.select_mountpoint_row_reformat(2)
        s.select_mountpoint_row_reformat(3, False)

        # Root should be preselected to reformat
        s.check_mountpoint_row(1, "/", "root", True, "btrfs")
        s.check_mountpoint_row(2, "/boot", "vda2", True, "ext4")
        s.check_mountpoint_row(3, "/home", "home", False, "btrfs")

        self.addCleanup(lambda: dbus_reset_users(m))
        i.reach(i.steps.REVIEW)

        # verify review screen
        dev = "vda"
        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, "vda2, 1.07 GB: format as ext4, /boot")
        r.check_disk_row(dev, "root, 15.0 GB: format as btrfs, /")
        r.check_disk_row(dev, "home, 15.0 GB: mount, /home")

        # Check fstab
        fstab = m.execute("cat /etc/fstab")
        self.assertTrue("/mnt/sysroot/boot auto noauto 0 0" in fstab)
        self.assertTrue("/mnt/sysroot/btrfs-mount-test auto subvol=/ 0 0" in fstab)
        self.assertTrue("/mnt/sysroot btrfs noauto,subvol=root 0 0" in fstab)
        self.assertTrue("/mnt/sysroot/home btrfs noauto,subvol=home 0 0" in fstab)


class TestStorageMountPointsEFI(anacondalib.VirtInstallMachineCase):
    efi = True

    def testBasic(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("500MiB", "efi"), ("1GB", "ext4"), ("", "xfs")])

        s.udevadm_settle()

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        s.select_mountpoint([(dev, True)])

        # verify gathered requests
        # root partition is not auto-mapped
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.select_mountpoint_row_device(1, f"{dev}3")
        s.check_mountpoint_row_format_type(1, "xfs")

        s.check_mountpoint_row(2, "/boot/efi", "Select a device", False)
        s.select_mountpoint_row_device(2, f"{dev}1")
        s.check_mountpoint_row_format_type(2, "EFI System Partition")

        s.check_mountpoint_row(3, "/boot", "Select a device", False)
        s.select_mountpoint_row_device(3, f"{dev}2")
        s.check_mountpoint_row_format_type(3, "ext4")

        self.addCleanup(lambda: dbus_reset_users(self.machine))
        i.reach(i.steps.REVIEW)

        # verify review screen
        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, "vda1, 524 MB: mount, /boot/efi")
        r.check_disk_row(dev, "vda2, 1.07 GB: mount, /boot")
        r.check_disk_row(dev, "vda3, 14.5 GB: format as xfs, /")


if __name__ == '__main__':
    test_main()
