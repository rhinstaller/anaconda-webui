#!/usr/bin/python3
#
# Copyright (C) 2022 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

import os

from anacondalib import VirtInstallMachineCase, disk_images, pixel_tests_ignore, run_boot
from installer import Installer
from review import Review
from storage import Storage
from storagelib import StorageCase  # pylint: disable=import-error
from testlib import nondestructive, skipImage, test_main  # pylint: disable=import-error
from utils import pretend_default_scheme

TEST_DIR = os.path.dirname(__file__)
ROOT_DIR = os.path.dirname(TEST_DIR)
BOTS_DIR = f'{ROOT_DIR}/bots'


class TestStorageMountPoints(VirtInstallMachineCase, StorageCase):
    # FIXME: Re-enable bios test, it's currently failing in CI to detect the BIOS boot partition
    # @run_boot("bios", "efi")
    @run_boot("efi")
    @disk_images([("", 15), ("fedora-41", "15")])
    @skipImage("btrfs support missing on fedora-eln image", "fedora-eln-boot")
    @nondestructive
    def testBasic(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)
        dev = "vdb"

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        s.select_mountpoint([("vda", False), ("vdb", True)])

        # verify gathered requests
        # root partition is not auto-mapped
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.select_mountpoint_row_device(1, "root")
        s.check_mountpoint_row_format_type(1, "btrfs")
        next_idx = 2

        def select_boot_mountpoints(next_idx=next_idx):
            if self.is_efi:
                s.select_mountpoint_row_device(next_idx, f"{dev}2")
                s.check_mountpoint_row_format_type(next_idx, "EFI System Partition")
                next_idx += 1

            s.check_mountpoint_row(next_idx, "/boot", "Select a device", False)
            s.select_mountpoint_row_device(next_idx, f"{dev}3")
            s.check_mountpoint_row_format_type(next_idx, "ext4")
            next_idx += 1

            return next_idx

        next_idx = select_boot_mountpoints()

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(next_idx, "home")
        s.check_mountpoint_row_reformat(next_idx, False)
        s.select_mountpoint_row_mountpoint(next_idx, "/home")
        s.check_mountpoint_row_format_type(next_idx, "btrfs")

        # Toggle reformat option
        s.select_mountpoint_row_reformat(next_idx - 1)

        if self.is_efi:
            s.select_mountpoint_row_reformat(next_idx - 2)

        # FIXME: https://github.com/cockpit-project/cockpit/pull/21392
        # b.assert_pixels(
        #     "#app",
        #     "mount-point-mapping-table",
        #     ignore=pixel_tests_ignore,
        # )

        i.reach(i.steps.REVIEW)

        # verify review screen
        r.check_disk(dev, "16.1 GB vdb (Virtio Block Device)")

        next_idx = 2
        if self.is_efi:
            r.check_disk_row(dev, "/boot/efi", f"vdb{next_idx}", "105 MB", True, "efi")
        next_idx += 1
        r.check_disk_row(dev, "/boot", f"vdb{next_idx}", "1.05 GB", True, "ext4")
        r.check_disk_row(dev, "/", f"vdb{next_idx + 1}", "12.8 GB", True, "btrfs subvolume")
        r.check_disk_row(dev, "/home", f"vdb{next_idx + 1}", "12.8 GB", False)

        applied_partitioning = s.dbus_get_applied_partitioning()

        # When adding a new partition a new partitioning should be created
        i.reach_on_sidebar(i.steps.INSTALLATION_METHOD)

        disk = "/dev/vdb"
        m.execute(f"sgdisk --new=0:0:0 {disk}")
        s.rescan_disks()
        s.select_mountpoint([("vda", False), ("vdb", True)])
        s.select_mountpoint_row_device(1, "root")
        select_boot_mountpoints()

        i.next()
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        self.assertNotEqual(new_applied_partitioning, applied_partitioning)

        # When going back and forward 'Next' button should not be disabled
        # https://bugzilla.redhat.com/show_bug.cgi?id=2242086
        i.back(previous_page=i.steps.CUSTOM_MOUNT_POINT)
        i.check_next_disabled(False)

        # Swap partitions should not be selectable for the required mount point rows
        # https://bugzilla.redhat.com/show_bug.cgi?id=2239836
        i.back()

        m.execute(f"mkswap {disk}5")
        s.rescan_disks()
        s.select_mountpoint([("vda", False), ("vdb", True)])
        s.check_mountpoint_row_device_available(1, f"{dev}5", True, True)

    def _testNoRootMountPoint_partition_disk(self):
        b = self.browser
        m = self.machine
        s = Storage(b, m)

        # BIOS boot /boot on ext4 / on xfs /home on btrfs
        disk = "/dev/vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("10GiB", "xfs"), ("", "ext4")])

    @nondestructive
    def testNoRootMountPoint(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        dev = "vda"
        s.select_mountpoint([(dev, True)])

        # verify gathered requests
        s.select_mountpoint_row_device(2, f"{dev}2")
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.check_mountpoint_row(2, "/boot", f"{dev}2", False, "ext4")

        # Test moving back and forth between screens.
        i.back()
        i.next(next_page=i.steps.CUSTOM_MOUNT_POINT)
        s.check_mountpoint_row(1, "/", "Select a device", True)
        s.check_mountpoint_row(2, "/boot", f"{dev}2", False, "ext4")

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(3, f"{dev}4")
        s.check_mountpoint_row_format_type(3, "ext4")
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.check_mountpoint_row_reformat(3, False)

        i.check_next_disabled()

    def _testMultipleDisks_partition_disk(self):
        b = self.browser
        m = self.machine
        s = Storage(b, m)

        # BIOS boot partition, /boot partition, /
        disk1 = "/dev/vda"
        s.partition_disk(disk1, [("1MiB", "biosboot"), ("1GB", "xfs"), ("", "xfs")])

        # /dev/vdb1 /home partition
        disk2 = "/dev/vdb"
        s.partition_disk(disk2, [("", "xfs")])

    @disk_images([("", 15), ("", 10)])
    @nondestructive
    def testMultipleDisks(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        dev1 = "vda"
        dev2 = "vdb"

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        # Select only vdb disk and verify that mount point assignment is
        # not available (missing biosboot)
        s.select_disks([(dev1, False), (dev2, True)])


        # RHBZ 2353002 - the biosboot constraint is not required, therefore the
        # scenario is available
        #s.wait_scenario_available("mount-point-mapping", False)
        s.wait_scenario_available("mount-point-mapping")
        # Let's check that the missing biosboot is caught later by validation
        s.select_mountpoint([(dev1, False), (dev2, True)])
        s.select_mountpoint_row_device(1, f"{dev2}1")
        s.check_mountpoint_row(1, "/", f"{dev2}1", True, "xfs")
        s.remove_mountpoint_row(2, 2)
        i.next(should_fail=True)
        b.wait_in_text(
            "#anaconda-screen-mount-point-mapping-step-notification",
            "Your BIOS-based system needs a special partition to boot from a GPT disk label."
        )
        i.back()

        # Select only vda disk and verify that the partitioning request is correct
        s.select_mountpoint([(dev1, True), (dev2, False)])

        s.check_mountpoint_row_device_available(1, "vdb1", False)
        s.check_mountpoint_row_device_available(1, "vda2")

        # Go back and change the disk selection. The partitioning should be re-created
        i.back()

        s.select_mountpoint([(dev1, True), (dev2, True)])

        s.check_mountpoint_row_device_available(1, "vda2", True)
        s.check_mountpoint_row_device_available(1, "vdb1")

        s.select_mountpoint_row_device(1, f"{dev1}3")
        s.check_mountpoint_row(1, "/", f"{dev1}3", True, "xfs")

        s.select_mountpoint_row_device(2, f"{dev1}2")
        s.check_mountpoint_row(2, "/boot", f"{dev1}2", False, "xfs")

        s.add_mountpoint_row()
        s.select_mountpoint_row_device(3, f"{dev2}1")
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.check_mountpoint_row(3, "/home", f"{dev2}1", False, "xfs")

        i.reach(i.steps.REVIEW)

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (Virtio Block Device)")
        r.check_disk_row(disk, "/boot", "vda2", "1.07 GB", False)
        r.check_disk_row(disk, "/", "vda3", "15.0 GB", True, "xfs")

        disk = "vdb"
        r.check_disk(disk, "10.7 GB vdb (Virtio Block Device)")
        r.check_disk_row(disk, "/home", "vdb1", "10.7 GB", False)

        b.assert_pixels(
            "#app",
            "review-multiple-disks",
            ignore=pixel_tests_ignore,
        )

    def move_standard_fedora_disk_to_MBR_disk(self, mbr_disk, new_disk):
        b = self.browser
        m = self.machine
        s = Storage(b, m)

        disk = mbr_disk
        dev = mbr_disk.split("/")[-1]
        dev_fedora = new_disk
        s.partition_disk(disk, [("1GiB", "ext4"), ("13GiB", "btrfs")], is_mbr=True)

        # Create standard btrfs layout in the empty disk and copy the data from the fedora
        # disk to emulate the installation on MBR disk.
        # Then eject the fedora disk
        self.machine.execute(f"""
        set -xe

        # Create btrfs layout
        mkfs.btrfs -f -L BTRFS {disk}2
        mount {disk}2 /mnt
        btrfs subvolume create /mnt/root
        btrfs subvolume create /mnt/home

        # Copy data from the first disk / to the new disk
        mkdir -p /mnt-fedora
        mount /dev/{dev_fedora}4 /mnt-fedora
        rsync -pogAXtlHrDx \
            --stats \
            --verbose \
            --progress \
            --exclude=/dev/* \
            --exclude=/proc/* \
            --exclude=/sys/* \
            --exclude=/tmp/* \
            --exclude=/run/* \
            --exclude=/mnt/* \
            --exclude=/media/* \
            --exclude=/lost+found \
            --exclude=/var/lib/machines \
            --exclude=/var \
            /mnt-fedora/* /mnt

        #/mnt-fedora/* /mnt
        # Adjust /etc/fstab to contain the new device UUIDS
        echo "UUID=$(blkid -s UUID -o value /dev/{dev}2) / btrfs defaults,subvol=root 0 0" > /mnt/root/etc/fstab
        echo "UUID=$(blkid -s UUID -o value /dev/{dev}2) /home btrfs defaults,subvol=home 0 0" >> /mnt/root/etc/fstab
        echo "UUID=$(blkid -s UUID -o value /dev/{dev}1) /boot ext4 defaults 0 0" >> /mnt/root/etc/fstab

        umount /mnt-fedora
        umount /mnt

        # Do the same for /boot
        mount /dev/{dev}1 /mnt
        mount /dev/{dev_fedora}3 /mnt-fedora
        rsync -aAXHv /mnt-fedora/ /mnt/

        umount /mnt-fedora
        umount /mnt
        """, timeout=90)


    def _testMBRParttable_partition_disk(self):
        self.move_standard_fedora_disk_to_MBR_disk("/dev/vda", "vdb")

    @disk_images([("", 15), ("fedora-41", 15)])
    def testMBRParttable(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        # This is required for home-reuse availability check
        pretend_default_scheme(self, "BTRFS")

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        s.wait_scenario_available("mount-point-mapping", True)
        s.wait_scenario_visible("home-reuse", False)

        s.select_mountpoint([("vda", True), ("vdb", False)])

        s.select_mountpoint_row_device(1, "root")
        s.select_mountpoint_row_device(2, "vda1")
        s.add_mountpoint_row()
        s.select_mountpoint_row_mountpoint(3, "/home")
        s.select_mountpoint_row_device(3, "home")

        s.select_mountpoint_row_reformat(2)

        i.reach(i.steps.REVIEW)

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (Virtio Block Device)")

        r.check_disk_row(disk, "/boot", "vda1", "1.07 GB", True, "ext4")
        r.check_disk_row(disk, "/", "vda2", "14.0 GB", True, "btrfs subvolume")
        r.check_disk_row(disk, "/home", "vda2", "14.0 GB", False, "btrfs")

    def _testEncryptedUnlock_partition_disk(self):
        b = self.browser
        m = self.machine
        s = Storage(b, m)

        disk1 = "/dev/vda"
        s.partition_disk(
            disk1,
            [("1MiB", "biosboot"), ("1GB", "xfs"), ("1GB", "xfs"), ("1GB", "xfs"), ("", "xfs")]
        )
        m.execute(f"""
        echo einszwei | cryptsetup luksFormat {disk1}2
        echo einszwei | cryptsetup luksOpen {disk1}2 encrypted-vol0
        mkfs.xfs -f /dev/mapper/encrypted-vol0
        cryptsetup luksClose encrypted-vol0
        echo einszweidrei | cryptsetup luksFormat {disk1}3
        echo einszweidrei | cryptsetup luksOpen {disk1}3 encrypted-vol1
        mkfs.xfs -f /dev/mapper/encrypted-vol1
        cryptsetup luksClose encrypted-vol1
        echo einszweidreivier | cryptsetup luksFormat {disk1}4
        echo einszweidreivier | cryptsetup luksOpen {disk1}4 encrypted-vol2
        mkfs.xfs -f /dev/mapper/encrypted-vol2
        cryptsetup luksClose encrypted-vol2
        """)

    @nondestructive
    def testEncryptedUnlock(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        dev1 = "vda"

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        s.unlock_all_encrypted()
        s.unlock_device("1234", ["vda2", "vda3", "vda4"], [])
        b.click("#unlock-device-dialog-close-btn")

        s.unlock_all_encrypted()
        s.unlock_device("einszwei", ["vda2", "vda3", "vda4"], ["vda2"])

        # The 'Unlock' dialog should stay open unless all LUKS devices are unlocked
        s.unlock_device("einszweidrei", ["vda3", "vda4"], ["vda3"])

        # The 'Unlock' dialog closes when all LUKS devices are unlocked
        s.unlock_device("einszweidreivier", ["vda4"], ["vda4"])

        s.select_mountpoint([(dev1, True)])
        b.wait_not_present(f"#{i.steps.CUSTOM_MOUNT_POINT}-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")

        self._testEncryptedUnlock(b, m)

    def _testEncryptedUnlock(self, b, m):
        dev1 = "vda"

        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        s.check_mountpoint_row_mountpoint(2, "/boot")
        s.select_mountpoint_row_device(2, "vda5")

        s.check_mountpoint_row_mountpoint(1, "/")
        selector = f"#{i.steps.CUSTOM_MOUNT_POINT}-table-row-1 .pf-v5-c-select__toggle"
        b.click(f"{selector}:not([disabled]):not([aria-disabled=true])")
        select_entry = f"{selector} + ul li:nth-of-type(3) button"
        b.click(select_entry)
        b.wait_in_text(f"{selector} .pf-v5-c-select__toggle-text", "luks")
        s.check_mountpoint_row_format_type(1, "xfs")

        i.reach(i.steps.REVIEW)

        r.check_disk_row(dev1, "/", "vda3", "", True, "xfs", True)

    @nondestructive
    def testEncryptedUnlockCockpit(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        _r = Review(b, m)  # noqa: F841

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.check_disk_selected("vda")

        s.modify_storage()
        s.confirm_entering_cockpit_storage()
        b.wait_visible(".cockpit-storage-integration-sidebar")
        s.check_constraint("/", True)
        # RHBZ 2353002 - the biosboot constraint is not required
        #s.check_constraint("biosboot", True)
        s.check_constraint("/boot", False)

        frame = "iframe[name='cockpit-storage']"
        b._wait_present(frame)
        b.switch_to_frame("cockpit-storage")
        b._wait_present("#storage.ct-page-fill")

        self.click_dropdown(self.card_row("Storage", 1), "Create partition table")
        self.confirm()

        self.click_dropdown(self.card_row("Storage", 2), "Create partition")
        self.dialog({"size": 1, "type": "biosboot"})

        self.click_dropdown(self.card_row("Storage", 3), "Create partition")
        self.dialog({
            "size": 1000,
            "type": "xfs",
            "crypto": self.default_crypto_type,
            "passphrase": "einszwei",
            "passphrase2": "einszwei",
        })

        self.click_dropdown(self.card_row("Storage", 4), "Create partition")
        self.dialog({
            "size": 1000,
            "type": "xfs",
            "crypto": self.default_crypto_type,
            "passphrase": "einszweidrei",
            "passphrase2": "einszweidrei",
        })

        self.click_dropdown(self.card_row("Storage", 5), "Create partition")
        self.dialog({
            "size": 1000,
            "type": "xfs",
            "crypto": self.default_crypto_type,
            "passphrase": "einszweidreivier",
            "passphrase2": "einszweidreivier",
        })

        self.click_dropdown(self.card_row("Storage", 6), "Create partition")
        self.dialog({"size": 1000, "type": "ext4"})

        # Exit the cockpit-storage iframe
        b.switch_to_top()
        s.return_to_installation()
        s.return_to_installation_confirm()
        i.wait_current_page(i.steps.INSTALLATION_METHOD)

        s.select_mountpoint([("vda", True)])

        self._testEncryptedUnlock(b, m)

    def _testDuplicateDeviceNames_partition_disk(self):
        b = self.browser
        m = self.machine
        s = Storage(b, m)

        disk = "/dev/vda"
        btrfsname = "home"
        s.partition_disk(
            disk,
            [
                ("1MiB", "biosboot"),
                ("1GB", "ext4"),
                ("5GiB", "btrfs", "-f", "-L", "root"),
                ("5GiB", "btrfs", "-f", "-L", btrfsname),
                ("", "btrfs", "-f", "-L", btrfsname)
            ]
        )

    @skipImage("btrfs support missing on fedora-eln image", "fedora-eln-boot")
    @nondestructive
    def testDuplicateDeviceNames(self):
        # https://bugzilla.redhat.com/show_bug.cgi?id=2237878
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b, m)

        btrfsname = "home"
        btrfs_volume_ids = s.get_btrfs_volume_ids(btrfsname)

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        s.select_mountpoint([("vda", True)])

        s.select_mountpoint_row_device(1, "root")
        s.select_mountpoint_row_device(2, "vda2")
        s.add_mountpoint_row()
        s.select_mountpoint_row_mountpoint(3, "/home/joe")
        s.select_mountpoint_row_device(3, "home", device_id=btrfs_volume_ids[0])
        s.add_mountpoint_row()
        s.select_mountpoint_row_mountpoint(4, "/home/alan")
        s.select_mountpoint_row_device(4, "home", device_id=btrfs_volume_ids[1])

        i.reach(i.steps.REVIEW)

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (Virtio Block Device)")

        r.check_disk_row(disk, "/boot", "vda2", "1.07 GB", False)
        r.check_disk_row(disk, "/", "vda3", "5.37 GB", True, "btrfs")
        r.check_disk_row(disk, "/home/joe", "vda4", "5.37 GB", False, "btrfs")
        r.check_disk_row(disk, "/home/alan", "vda5", "4.29 GB", False, "btrfs")

    def _testUnusableFormats_partition_disk(self):
        b = self.browser
        m = self.machine
        s = Storage(b, m)

        disk = "/dev/vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("1GB", None), ("1GB", "lvmpv")])

    @nondestructive
    def testUnusableFormats(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        dev = "vda"

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)
        s.rescan_disks()

        s.select_mountpoint([(dev, True)])

        # unformatted and unmountable devices should not be available
        s.check_mountpoint_row_device_available(1, f"{dev}3", False)
        s.check_mountpoint_row_device_available(1, f"{dev}4", False)

    def _testExtendedPartition_partition_disk(self):
        b = self.browser
        m = self.machine
        s = Storage(b, m)

        # Configure disk layout with a logical Btrfs partition
        disk = "/dev/vda"
        s.partition_disk(
            disk,
            [
                ("512MB", "efi"),
                ("1GB", "ext4"),
                ("", "extended"),
                ("10GB", "logical")
            ],
            is_mbr=True
        )

        # Create subvolumes for the logical Btrfs partition
        m.execute(f"""
        mkfs.btrfs -f -L BTRFS {disk}5
        mount {disk}5 /mnt
        btrfs subvolume create /mnt/root
        btrfs subvolume create /mnt/home
        umount /mnt
        """)

    @run_boot("efi")
    @nondestructive
    def testExtendedPartition(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        i.open()
        i.reach(i.steps.INSTALLATION_METHOD)

        s.select_mountpoint([("vda", True)])

        s.select_mountpoint_row_device(1, "root")
        s.select_mountpoint_row_device(2, "vda1")
        s.select_mountpoint_row_device(3, "vda2")
        s.add_mountpoint_row()
        s.select_mountpoint_row_mountpoint(4, "/home")
        s.select_mountpoint_row_device(4, "home")


if __name__ == '__main__':
    test_main()
